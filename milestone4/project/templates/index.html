<!-- templates/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Gesture-Based Volume Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root{
      --bg1:#0f1222;
      --bg2:#1a1f3b;
      --accent:#6ee7ff;
      --accent2:#8b5cf6;
      --text:#e8edf7;
      --muted:#a7afc9;
      --danger:#ff6b6b;
      --warn:#fbbf24;
      --ok:#22d3ee;
      --green:#10b981;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:Inter,Segoe UI,Roboto,Arial,Helvetica,sans-serif;
      color:var(--text);
      background:linear-gradient(135deg,var(--bg1),var(--bg2));
      min-height:100vh;
      display:flex;
      flex-direction:column;
    }
    header{
      padding:24px 28px;
      display:flex;
      align-items:center;
      justify-content:space-between;
    }
    .brand{
      display:flex;
      align-items:center;
      gap:12px;
      font-weight:700;
      letter-spacing:0.3px;
    }
    .brand .dot{
      width:14px; height:14px; border-radius:50%;
      background:linear-gradient(135deg,var(--accent),var(--accent2));
      box-shadow:0 0 16px rgba(110,231,255,.6);
      animation:pulse 2.4s ease-in-out infinite;
    }
    @keyframes pulse{
      0%,100%{transform:scale(1); box-shadow:0 0 14px rgba(110,231,255,.55)}
      50%{transform:scale(1.2); box-shadow:0 0 24px rgba(110,231,255,.9)}
    }
    .container{
      flex:1;
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:20px;
      padding:0 28px 28px;
    }
    @media (max-width: 980px){
      .container{grid-template-columns:1fr}
    }
    .card{
      background:rgba(255,255,255,.06);
      backdrop-filter: blur(10px);
      border:1px solid rgba(255,255,255,.1);
      border-radius:16px;
      box-shadow:0 10px 24px rgba(0,0,0,.25);
      overflow:hidden;
    }
    .card header{
      padding:14px 16px;
      border-bottom:1px solid rgba(255,255,255,.08);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    }
    .card header h2{
      font-size:16px;
      margin:0;
      font-weight:600;
      color:#f1f5f9;
    }
    .video-wrapper{
      position:relative;
      display:flex;
      align-items:center;
      justify-content:center;
      background:radial-gradient(1200px 600px at 50% 50%, rgba(110,231,255,.08), transparent 60%);
    }
    .video{
      width:100%;
      max-height:65vh;
      object-fit:contain;
      background:#000;
    }
    .overlay{
      position:absolute;
      right:12px; bottom:12px;
      display:flex; gap:10px; align-items:center;
      padding:8px 10px;
      background:rgba(0,0,0,.4);
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      font-size:12px;
      color:var(--muted);
    }
    .stat{
      display:flex; gap:6px; align-items:center;
      padding:6px 8px; border-radius:10px;
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.08);
    }
    .stat .dot{width:8px;height:8px;border-radius:50%}
    .stat .dot.ok{background:var(--green)}
    .stat .dot.warn{background:var(--warn)}
    .stat .dot.danger{background:var(--danger)}
    .panel{
      padding:16px;
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:16px;
    }
    @media (max-width: 640px){
      .panel{grid-template-columns:1fr}
    }
    .metric{
      padding:14px;
      border:1px dashed rgba(255,255,255,.14);
      border-radius:12px;
      background:rgba(255,255,255,.04);
      transition:transform .2s ease, box-shadow .2s ease;
    }
    .metric:hover{
      transform:translateY(-2px);
      box-shadow:0 8px 18px rgba(0,0,0,.25);
    }
    .metric .label{font-size:12px;color:var(--muted);margin-bottom:6px}
    .metric .value{font-size:20px;font-weight:700}
    .level-tag{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border-radius:20px; font-size:12px; font-weight:600;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.1);
    }
    .level-low{color:#93c5fd}
    .level-med{color:#fbbf24}
    .level-high{color:#fca5a5}

    .vol-bar{
      width:100%; height:14px; border-radius:999px;
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.12);
      overflow:hidden;
    }
    .vol-fill{
      height:100%;
      width:0%;
      background:linear-gradient(90deg, var(--accent), var(--accent2));
      box-shadow:0 0 16px rgba(139,92,246,.6);
      transition:width .18s ease-in-out;
    }

    .controls{
      padding:16px;
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:16px;
    }
    @media (max-width: 720px){
      .controls{grid-template-columns:1fr}
    }
    .control{
      padding:14px;
      border:1px solid rgba(255,255,255,.1);
      border-radius:12px;
      background:rgba(255,255,255,.04);
    }
    .control h3{
      margin:0 0 10px 0; font-size:14px; color:#e5e7eb;
    }
    .control .row{
      display:flex; gap:10px; align-items:center; margin-bottom:10px;
    }
    input[type="number"]{
      flex:1;
      padding:10px 12px; border-radius:10px;
      border:1px solid rgba(255,255,255,.2);
      background:rgba(0,0,0,.2);
      color:var(--text);
      outline:none;
      transition:border .2s ease, box-shadow .2s ease;
    }
    input[type="number"]:focus{
      border-color:var(--accent);
      box-shadow:0 0 0 3px rgba(110,231,255,.15);
    }
    .btn{
      padding:10px 14px; border-radius:10px; border:none; cursor:pointer;
      font-weight:600; color:#0b1020;
      background:linear-gradient(135deg, var(--accent), var(--accent2));
      box-shadow:0 10px 24px rgba(139,92,246,.35);
      transition:transform .15s ease, box-shadow .15s ease;
    }
    .btn:hover{ transform:translateY(-1px); box-shadow:0 14px 28px rgba(139,92,246,.45) }
    .btn.secondary{
      background:linear-gradient(135deg, #60a5fa, #34d399);
      box-shadow:0 10px 24px rgba(96,165,250,.35);
    }
    .btn.ghost{
      background:rgba(255,255,255,.06);
      color:#dbeafe;
      border:1px solid rgba(255,255,255,.12);
      box-shadow:none;
    }
    canvas#graph{
      width:100%; height:140px; display:block;
      background:radial-gradient(800px 400px at 50% 50%, rgba(139,92,246,.08), transparent 60%);
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
    }
    footer{
      padding:12px 28px; font-size:12px; color:var(--muted);
      display:flex; align-items:center; justify-content:space-between;
      border-top:1px solid rgba(255,255,255,.08);
      background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
    }
  </style>
</head>
<body>
  <header>
    <div class="brand">
      <div class="dot"></div>
      <div>Gesture-Based Volume Control</div>
    </div>
    <div class="level-tag" id="levelTag"><span>Level</span><strong id="levelText">LOW</strong></div>
  </header>

  <div class="container">
    <div class="card">
      <header><h2>Live webcam feed</h2></header>
      <div class="video-wrapper">
        <img id="video" class="video" src="/video_feed" alt="Video stream (MJPEG)" />
        <div class="overlay">
          <div class="stat"><span class="dot ok"></span><span id="fps">FPS: --</span></div>
          <div class="stat"><span class="dot warn"></span><span id="resp">Response: -- ms</span></div>
          <div class="stat"><span class="dot danger"></span><span id="gesture">Gesture: --</span></div>
        </div>
      </div>
      <div class="panel">
        <div class="metric">
          <div class="label">Thumb–Index distance</div>
          <div class="value" id="distance">-- px</div>
        </div>
        <div class="metric">
          <div class="label">System volume</div>
          <div class="value" id="volume">-- %</div>
          <div class="vol-bar" style="margin-top:10px;">
            <div class="vol-fill" id="volFill"></div>
          </div>
        </div>
        <div class="metric" style="grid-column: 1 / -1;">
          <div class="label">Live distance graph</div>
          <canvas id="graph"></canvas>
        </div>
      </div>
    </div>

    <div class="card">
      <header><h2>Calibration & controls</h2></header>
      <div class="controls">
        <div class="control">
          <h3>Manual calibration</h3>
          <div class="row">
            <input type="number" id="minPx" placeholder="Min distance (px)" step="1" min="0" max="500" />
            <input type="number" id="maxPx" placeholder="Max distance (px)" step="1" min="0" max="500" />
          </div>
          <div class="row">
            <button class="btn" id="applyBtn">Apply</button>
            <button class="btn ghost" id="resetBtn">Reset</button>
          </div>
          <div class="row" style="font-size:12px;color:var(--muted);">
            Tip: Pinch for Min, fully open hand for Max.
          </div>
        </div>
        <div class="control">
          <h3>Auto-calibration</h3>
          <div class="row">
            <button class="btn secondary" id="autoBtn">Auto-calibrate</button>
          </div>
          <div class="row" id="status" style="font-size:12px;color:var(--muted);">Move through your full range, then press Auto-calibrate.</div>
        </div>
      </div>
    </div>
  </div>

  <footer>
    <div>Continuous MJPEG stream • Real Windows system volume control • Smoothed & responsive</div>
    <div>Made for localhost (127.0.0.1:5000)</div>
  </footer>

  <script>
    const fpsEl = document.getElementById('fps');
    const respEl = document.getElementById('resp');
    const gestureEl = document.getElementById('gesture');
    const distanceEl = document.getElementById('distance');
    const volumeEl = document.getElementById('volume');
    const volFillEl = document.getElementById('volFill');
    const levelText = document.getElementById('levelText');
    const levelTag = document.getElementById('levelTag');

    const minPxInput = document.getElementById('minPx');
    const maxPxInput = document.getElementById('maxPx');
    const applyBtn = document.getElementById('applyBtn');
    const resetBtn = document.getElementById('resetBtn');
    const autoBtn = document.getElementById('autoBtn');
    const statusEl = document.getElementById('status');

    // Graph setup
    const canvas = document.getElementById('graph');
    const ctx = canvas.getContext('2d');
    function resizeCanvas(){
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function drawGraph(series){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // Axes
      ctx.strokeStyle = 'rgba(255,255,255,.15)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(32, 8);
      ctx.lineTo(32, canvas.height-24);
      ctx.lineTo(canvas.width-8, canvas.height-24);
      ctx.stroke();

      if(!series || series.length < 2) return;
      const plotW = canvas.width - 40;
      const plotH = canvas.height - 40;
      const x0 = 32, y0 = canvas.height - 24;

      const minV = Math.min(...series);
      const maxV = Math.max(...series);
      const span = Math.max(1, maxV - minV);

      ctx.lineWidth = 2;
      const grad = ctx.createLinearGradient(0,0,canvas.width,0);
      grad.addColorStop(0, '#6ee7ff');
      grad.addColorStop(1, '#8b5cf6');
      ctx.strokeStyle = grad;

      ctx.beginPath();
      for(let i=0;i<series.length;i++){
        const x = x0 + (i/(series.length-1))*plotW;
        const y = y0 - ((series[i]-minV)/span)*plotH;
        if(i===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
      }
      ctx.stroke();

      // Fill under curve (soft)
      ctx.fillStyle = 'rgba(139,92,246,.10)';
      ctx.lineTo(x0 + plotW, y0);
      ctx.lineTo(x0, y0);
      ctx.closePath();
      ctx.fill();

      // Labels
      ctx.fillStyle = 'rgba(255,255,255,.6)';
      ctx.font = '12px Segoe UI, Arial';
      ctx.fillText(`min: ${minV.toFixed(1)} px`, x0+6, 16);
      ctx.fillText(`max: ${maxV.toFixed(1)} px`, x0+120, 16);
    }

    function setLevel(level){
      levelText.textContent = level || 'LOW';
      levelTag.classList.remove('level-low','level-med','level-high');
      if(level === 'LOW') levelTag.classList.add('level-low');
      else if(level === 'MEDIUM') levelTag.classList.add('level-med');
      else levelTag.classList.add('level-high');
    }

    async function fetchMetrics(){
      try{
        const res = await fetch('/metrics', {cache:'no-store'});
        const data = await res.json();

        fpsEl.textContent = `FPS: ${data.fps}`;
        respEl.textContent = `Response: ${data.response_ms} ms`;
        gestureEl.textContent = `Gesture: ${data.gesture || 'None'}`;
        distanceEl.textContent = `${data.distance_px?.toFixed ? data.distance_px.toFixed(1) : data.distance_px} px`;
        volumeEl.textContent = `${data.smoothed_volume_percent?.toFixed ? data.smoothed_volume_percent.toFixed(1) : data.smoothed_volume_percent} %`;
        volFillEl.style.width = `${data.smoothed_volume_percent || 0}%`;
        setLevel(data.semantic_level);

        drawGraph(data.distance_graph || []);
      }catch(e){
        // keep UI responsive even if polling fails
      }
    }

    // Poll metrics at ~5 Hz (every 200 ms)
    setInterval(fetchMetrics, 200);
    fetchMetrics();

    applyBtn.addEventListener('click', async ()=>{
      const minPx = parseFloat(minPxInput.value);
      const maxPx = parseFloat(maxPxInput.value);
      if(isNaN(minPx) || isNaN(maxPx)){
        statusEl.textContent = 'Enter valid numeric values for Min/Max.';
        statusEl.style.color = 'var(--danger)';
        return;
      }
      try{
        const res = await fetch('/calibrate', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body:JSON.stringify({min_px:minPx, max_px:maxPx})
        });
        const data = await res.json();
        if(data.ok){
          statusEl.textContent = `Applied: Min ${data.min_px.toFixed(1)} px, Max ${data.max_px.toFixed(1)} px`;
          statusEl.style.color = 'var(--ok)';
        }else{
          statusEl.textContent = data.message || 'Calibration failed.';
          statusEl.style.color = 'var(--danger)';
        }
      }catch(e){
        statusEl.textContent = 'Calibration request failed.';
        statusEl.style.color = 'var(--danger)';
      }
    });

    resetBtn.addEventListener('click', ()=>{
      minPxInput.value = '';
      maxPxInput.value = '';
      statusEl.textContent = 'Reset inputs. Tip: Pinch for Min, fully open hand for Max.';
      statusEl.style.color = 'var(--muted)';
    });

    autoBtn.addEventListener('click', async ()=>{
      statusEl.textContent = 'Auto-calibrating...';
      statusEl.style.color = 'var(--muted)';
      try{
        const res = await fetch('/auto_calibrate', { method:'POST' });
        const data = await res.json();
        if(data.ok){
          statusEl.textContent = `Auto-calibrated: Min ${data.min_px.toFixed(1)} px, Max ${data.max_px.toFixed(1)} px`;
          statusEl.style.color = 'var(--ok)';
          minPxInput.value = data.min_px.toFixed(1);
          maxPxInput.value = data.max_px.toFixed(1);
        }else{
          statusEl.textContent = data.message || 'Auto-calibration failed.';
          statusEl.style.color = 'var(--danger)';
        }
      }catch(e){
        statusEl.textContent = 'Auto-calibration request failed.';
        statusEl.style.color = 'var(--danger)';
      }
    });
  </script>
</body>
</html>